package main

import (
	"context"
	"flag"
	"fmt"
	"log/slog"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"time"

	"github.com/nijaru/github-grid/dateutil"
	"github.com/nijaru/github-grid/git"
)

const (
	dateFormat      = "2006-01-02 15:04:05 -0700"
	shortDateFormat = "2006-01-02"

	filename            = "edit.txt"
	maxRetries          = 3
	defaultStartDaysAgo = -371
)

func normalizeDateString(date string) (string, error) {
	if date == "" {
		return date, nil
	}

	parts := strings.Split(date, "-")
	if len(parts) != 3 {
		return date, fmt.Errorf("invalid date format")
	}

	year := parts[0]

	monthInt, err := strconv.Atoi(parts[1])
	if err != nil {
		return "", fmt.Errorf("invalid month: %w", err)
	}
	month := fmt.Sprintf("%02d", monthInt)

	dayInt, err := strconv.Atoi(parts[2])
	if err != nil {
		return "", fmt.Errorf("invalid day: %w", err)
	}
	day := fmt.Sprintf("%02d", dayInt)

	return fmt.Sprintf("%s-%s-%s", year, month, day), nil
}

func parseDateRange(
	gitOps *git.GitOperations,
	startStr, endStr string,
) (time.Time, time.Time, error) {
	var startDate, endDate time.Time
	var err error

	// Normalize the date strings
	startStr, err = normalizeDateString(startStr)
	if err != nil {
		return time.Time{}, time.Time{}, fmt.Errorf("invalid start date format: %w", err)
	}
	endStr, err = normalizeDateString(endStr)
	if err != nil {
		return time.Time{}, time.Time{}, fmt.Errorf("invalid end date format: %w", err)
	}

	// Determine the end date
	if endStr == "" {
		endDate = time.Now()
	} else {
		endDate, err = time.Parse(shortDateFormat, endStr)
		if err != nil {
			return time.Time{}, time.Time{}, fmt.Errorf("invalid end date: %w", err)
		}
	}

	// Determine the start date
	if startStr == "" {
		// If no start date is provided, check for the last auto-generated commit
		latestCommitDate, err := gitOps.GetLatestAutoGeneratedCommitDate(context.Background())
		if err != nil {
			// If no prior commits found, default to a year's worth
			gitOps.Logger().
				Info("No previous auto-generated commits found. Starting from a year ago.")
			startDate = time.Now().AddDate(0, 0, defaultStartDaysAgo) // Start from 371 days ago
		} else {
			gitOps.Logger().Info("Found latest auto-generated commit date.", "date", latestCommitDate.Format(shortDateFormat))
			// Start from the day after the latest commit
			startDate = latestCommitDate.AddDate(0, 0, 1)
		}
	} else {
		startDate, err = time.Parse(shortDateFormat, startStr)
		if err != nil {
			return time.Time{}, time.Time{}, fmt.Errorf("invalid start date: %w", err)
		}
	}

	if startDate.After(endDate) {
		return time.Time{}, time.Time{}, fmt.Errorf("start date cannot be after end date")
	}

	return startDate, endDate, nil
}

// processCommit handles the committing process for a single commit time
func processCommit(ctx context.Context, gitOps *git.GitOperations, commitTime time.Time) error {
	content := commitTime.Format(dateFormat)

	if _, err := os.Stat(filename); err == nil {
		// File exists, handle accordingly
		gitOps.Logger().Warn("File already exists, overwriting", "filename", filename)
	}

	if err := os.WriteFile(filename, []byte(content+"\n"), 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	if err := gitOps.CommitChanges(ctx, commitTime); err != nil {
		return err
	}

	if err := os.Remove(filename); err != nil {
		gitOps.Logger().Warn("Failed to remove file", "filename", filename, "error", err)
	}

	return nil
}

// processSingleDay handles all commits for a single day
func processSingleDay(ctx context.Context, gitOps *git.GitOperations, date time.Time) error {
	if dateutil.ShouldSkipDay(date) {
		gitOps.Logger().Info("Skipping day", "date", date.Format(shortDateFormat))
		return nil
	}

	commitTimes := dateutil.GenerateCommitTimes(date)
	for _, commitTime := range commitTimes {
		select {
		case <-ctx.Done():
			return fmt.Errorf("operation cancelled")
		default:
			if err := processCommit(ctx, gitOps, commitTime); err != nil {
				return err
			}
		}
	}
	return nil
}

// processDateRange handles the range of dates for committing
func processDateRange(
	ctx context.Context,
	gitOps *git.GitOperations,
	startDate, endDate time.Time,
) error {
	if err := gitOps.EnsureGitRepository(ctx); err != nil {
		return err
	}

	if err := gitOps.EnsureMainBranch(ctx); err != nil {
		return err
	}

	dayCount := 0
	for current := startDate; !current.After(endDate); current = current.AddDate(0, 0, 1) {
		select {
		case <-ctx.Done():
			return fmt.Errorf("operation cancelled")
		default:
			if err := processSingleDay(ctx, gitOps, current); err != nil {
				return fmt.Errorf(
					"failed to process date %s: %w",
					current.Format(shortDateFormat),
					err,
				)
			}

			dayCount++
			// Push commits every 10 days
			if dayCount%10 == 0 {
				if err := gitOps.PushCommits(ctx); err != nil {
					return err
				}
			}
		}
	}

	// Final push
	return gitOps.PushCommits(ctx)
}

func main() {
	startDateStr := flag.String("start", "", "Start date (YYYY-MM-DD)")
	endDateStr := flag.String("end", "", "End date (YYYY-MM-DD)")
	flag.Parse()

	// Initialize a new logger with a text handler
	logger := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
		AddSource: true,
		Level:     slog.LevelInfo,
	}))
	gitOps := git.NewGitOperations(logger)

	// Handle interrupt signal
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt)
	done := make(chan bool)

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	go func() {
		<-sigChan
		logger.Info("Received interrupt signal. Shutting down...")
		cancel()
		done <- true
	}()

	startDate, endDate, err := parseDateRange(gitOps, *startDateStr, *endDateStr)
	if err != nil {
		logger.Error("Failed to parse dates", "error", err)
		os.Exit(1)
	}

	logger.Info(
		"Generating commits",
		"startDate",
		startDate.Format(shortDateFormat),
		"endDate",
		endDate.Format(shortDateFormat),
	)

	if err := processDateRange(ctx, gitOps, startDate, endDate); err != nil {
		logger.Error("Failed to process commits", "error", err)
		os.Exit(1)
	}

	done <- true
	<-done
	logger.Info("Successfully completed all operations")
}
