package main

import (
	"context"
	"flag"
	"fmt"
	"log/slog"
	"os"
	"os/signal"
	"time"

	"github.com/nijaru/github-grid/git"
)

// Constants for date formats and default settings
const (
	dateFormat          = "2006-01-02 15:04:05 -0700"
	shortDateFormat     = "2006-01-02"
	filename            = "edit.txt"
	maxRetries          = 3
	defaultStartDaysAgo = -371
)

// normalizeDateString formats the input date string to "YYYY-MM-DD" using time.Parse for robustness
func normalizeDateString(date string) (string, error) {
	if date == "" {
		return date, nil
	}

	parsedDate, err := time.Parse(shortDateFormat, date)
	if err != nil {
		return "", fmt.Errorf("invalid date format: %w", err)
	}

	return parsedDate.Format(shortDateFormat), nil
}

// parseDateRange determines the start and end dates for committing based on input strings
func parseDateRange(
	gitOps *git.GitOperations,
	startStr, endStr string,
) (time.Time, time.Time, error) {
	var startDate, endDate time.Time
	var err error

	// Normalize the date strings
	startStr, err = normalizeDateString(startStr)
	if err != nil {
		return time.Time{}, time.Time{}, fmt.Errorf("invalid start date format: %w", err)
	}
	endStr, err = normalizeDateString(endStr)
	if err != nil {
		return time.Time{}, time.Time{}, fmt.Errorf("invalid end date format: %w", err)
	}

	// Determine the end date
	if endStr == "" {
		endDate = time.Now()
	} else {
		endDate, err = time.Parse(shortDateFormat, endStr)
		if err != nil {
			return time.Time{}, time.Time{}, fmt.Errorf("invalid end date: %w", err)
		}
	}

	// Determine the start date
	if startStr == "" {
		// If no start date is provided, check for the last auto-generated commit
		latestCommitDate, err := gitOps.GetLatestAutoGeneratedCommitDate(context.Background())
		if err != nil {
			// If no prior commits found, default to a year's worth
			gitOps.Logger().Info("No previous auto-generated commits found. Starting from a year ago.")
			startDate = time.Now().AddDate(0, 0, defaultStartDaysAgo) // Start from 371 days ago
		} else {
			gitOps.Logger().Info("Found latest auto-generated commit date.", "date", latestCommitDate.Format(shortDateFormat))
			// Start from the day after the latest commit
			startDate = latestCommitDate.AddDate(0, 0, 1)
		}
	} else {
		startDate, err = time.Parse(shortDateFormat, startStr)
		if err != nil {
			return time.Time{}, time.Time{}, fmt.Errorf("invalid start date: %w", err)
		}
	}

	if startDate.After(endDate) {
		return time.Time{}, time.Time{}, fmt.Errorf("start date cannot be after end date")
	}

	return startDate, endDate, nil
}

func main() {
	startDateStr := flag.String("start", "", "Start date (YYYY-MM-DD)")
	endDateStr := flag.String("end", "", "End date (YYYY-MM-DD)")
	flag.Parse()

	logger := slog.New(slog.NewTextHandler(os.Stdout, nil))
	gitOps := git.NewGitOperations(logger)

	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
	defer stop()

	startDate, endDate, err := parseDateRange(gitOps, *startDateStr, *endDateStr)
	if err != nil {
		logger.Error("Failed to parse dates", "error", err)
		os.Exit(1)
	}

	logger.Info(
		"Generating commits",
		"startDate",
		startDate.Format(shortDateFormat),
		"endDate",
		endDate.Format(shortDateFormat),
	)

	if err := gitOps.ProcessDateRange(ctx, startDate, endDate); err != nil {
		logger.Error("Failed to process commits", "error", err)
		os.Exit(1)
	}

	logger.Info("Successfully completed all operations")
}
